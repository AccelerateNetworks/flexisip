// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "resource-lists.hxx"

namespace resource_lists
{
  // display-nameType
  //

  bool display_nameType::
  lang_present () const
  {
    return this->lang_present_;
  }

  void display_nameType::
  lang_present (bool x)
  {
    this->lang_present_ = x;
  }

  const ::namespace_::lang& display_nameType::
  lang () const
  {
    return this->lang_;
  }

  ::namespace_::lang& display_nameType::
  lang ()
  {
    return this->lang_;
  }

  void display_nameType::
  lang (const ::namespace_::lang& x)
  {
    this->lang_ = x;
    this->lang_present_ = true;
  }

  // display-name
  //

  // entryType
  //

  const ::std::string& entryType::
  uri () const
  {
    return this->uri_;
  }

  ::std::string& entryType::
  uri ()
  {
    return this->uri_;
  }

  void entryType::
  uri (const ::std::string& x)
  {
    this->uri_ = x;
  }

  bool entryType::
  display_name_present () const
  {
    return this->display_name_present_;
  }

  void entryType::
  display_name_present (bool x)
  {
    this->display_name_present_ = x;
  }

  const ::resource_lists::display_name& entryType::
  display_name () const
  {
    return this->display_name_;
  }

  ::resource_lists::display_name& entryType::
  display_name ()
  {
    return this->display_name_;
  }

  void entryType::
  display_name (const ::resource_lists::display_name& x)
  {
    this->display_name_ = x;
    this->display_name_present_ = true;
  }

  // entry-refType
  //

  const ::std::string& entry_refType::
  ref () const
  {
    return this->ref_;
  }

  ::std::string& entry_refType::
  ref ()
  {
    return this->ref_;
  }

  void entry_refType::
  ref (const ::std::string& x)
  {
    this->ref_ = x;
  }

  bool entry_refType::
  display_name_present () const
  {
    return this->display_name_present_;
  }

  void entry_refType::
  display_name_present (bool x)
  {
    this->display_name_present_ = x;
  }

  const ::resource_lists::display_nameType& entry_refType::
  display_name () const
  {
    return this->display_name_;
  }

  ::resource_lists::display_nameType& entry_refType::
  display_name ()
  {
    return this->display_name_;
  }

  void entry_refType::
  display_name (const ::resource_lists::display_nameType& x)
  {
    this->display_name_ = x;
    this->display_name_present_ = true;
  }

  // externalType
  //

  bool externalType::
  anchor_present () const
  {
    return this->anchor_present_;
  }

  void externalType::
  anchor_present (bool x)
  {
    this->anchor_present_ = x;
  }

  const ::std::string& externalType::
  anchor () const
  {
    return this->anchor_;
  }

  ::std::string& externalType::
  anchor ()
  {
    return this->anchor_;
  }

  void externalType::
  anchor (const ::std::string& x)
  {
    this->anchor_ = x;
    this->anchor_present_ = true;
  }

  bool externalType::
  display_name_present () const
  {
    return this->display_name_present_;
  }

  void externalType::
  display_name_present (bool x)
  {
    this->display_name_present_ = x;
  }

  const ::resource_lists::display_nameType& externalType::
  display_name () const
  {
    return this->display_name_;
  }

  ::resource_lists::display_nameType& externalType::
  display_name ()
  {
    return this->display_name_;
  }

  void externalType::
  display_name (const ::resource_lists::display_nameType& x)
  {
    this->display_name_ = x;
    this->display_name_present_ = true;
  }

  // listType
  //

  bool listType::
  name_present () const
  {
    return this->name_present_;
  }

  void listType::
  name_present (bool x)
  {
    this->name_present_ = x;
  }

  const ::std::string& listType::
  name () const
  {
    return this->name_;
  }

  ::std::string& listType::
  name ()
  {
    return this->name_;
  }

  void listType::
  name (const ::std::string& x)
  {
    this->name_ = x;
    this->name_present_ = true;
  }

  bool listType::
  display_name_present () const
  {
    return this->display_name_present_;
  }

  void listType::
  display_name_present (bool x)
  {
    this->display_name_present_ = x;
  }

  const ::resource_lists::display_nameType& listType::
  display_name () const
  {
    return this->display_name_;
  }

  ::resource_lists::display_nameType& listType::
  display_name ()
  {
    return this->display_name_;
  }

  void listType::
  display_name (const ::resource_lists::display_nameType& x)
  {
    this->display_name_ = x;
    this->display_name_present_ = true;
  }

  const listType::sequence_sequence& listType::
  sequence () const
  {
    return this->sequence_;
  }

  listType::sequence_sequence& listType::
  sequence ()
  {
    return this->sequence_;
  }

  listType::sequence_type::choice_arm_tag listType::sequence_type::
  choice_arm () const
  {
    return this->choice_arm_;
  }

  const ::resource_lists::list& listType::sequence_type::
  list () const
  {
    return *this->choice_.list_;
  }

  ::resource_lists::list& listType::sequence_type::
  list ()
  {
    return *this->choice_.list_;
  }

  void listType::sequence_type::
  list (::resource_lists::list* x)
  {
    if (this->choice_arm_ != list_tag)
      this->choice_arm (list_tag);
    else
    {
      delete this->choice_.list_;
    }

    this->choice_.list_ = x;
  }

  const ::resource_lists::externalType& listType::sequence_type::
  external () const
  {
    return reinterpret_cast< const ::resource_lists::externalType& > (this->choice_.external_);
  }

  ::resource_lists::externalType& listType::sequence_type::
  external ()
  {
    return reinterpret_cast< ::resource_lists::externalType& > (this->choice_.external_);
  }

  void listType::sequence_type::
  external (const ::resource_lists::externalType& x)
  {
    if (this->choice_arm_ != external_tag)
      this->choice_arm (external_tag);

    reinterpret_cast< ::resource_lists::externalType& > (this->choice_.external_) = x;
  }

  const ::resource_lists::entryType& listType::sequence_type::
  entry () const
  {
    return reinterpret_cast< const ::resource_lists::entryType& > (this->choice_.entry_);
  }

  ::resource_lists::entryType& listType::sequence_type::
  entry ()
  {
    return reinterpret_cast< ::resource_lists::entryType& > (this->choice_.entry_);
  }

  void listType::sequence_type::
  entry (const ::resource_lists::entryType& x)
  {
    if (this->choice_arm_ != entry_tag)
      this->choice_arm (entry_tag);

    reinterpret_cast< ::resource_lists::entryType& > (this->choice_.entry_) = x;
  }

  const ::resource_lists::entry_refType& listType::sequence_type::
  entry_ref () const
  {
    return reinterpret_cast< const ::resource_lists::entry_refType& > (this->choice_.entry_ref_);
  }

  ::resource_lists::entry_refType& listType::sequence_type::
  entry_ref ()
  {
    return reinterpret_cast< ::resource_lists::entry_refType& > (this->choice_.entry_ref_);
  }

  void listType::sequence_type::
  entry_ref (const ::resource_lists::entry_refType& x)
  {
    if (this->choice_arm_ != entry_ref_tag)
      this->choice_arm (entry_ref_tag);

    reinterpret_cast< ::resource_lists::entry_refType& > (this->choice_.entry_ref_) = x;
  }

  // list
  //

  // resource-lists
  //

  const resource_lists::sequence_sequence& resource_lists::
  sequence () const
  {
    return this->sequence_;
  }

  resource_lists::sequence_sequence& resource_lists::
  sequence ()
  {
    return this->sequence_;
  }

  const ::resource_lists::listType& resource_lists::sequence_type::
  list () const
  {
    return *this->list_;
  }

  ::resource_lists::listType& resource_lists::sequence_type::
  list ()
  {
    return *this->list_;
  }

  void resource_lists::sequence_type::
  list (::resource_lists::listType* x)
  {
    delete this->list_;
    this->list_ = x;
  }
}

#include <stdlib.h>
#include <new>

namespace resource_lists
{
  // display-nameType
  //

  display_nameType::
  display_nameType ()
  {
    this->lang_present_ = false;
  }

  display_nameType::
  ~display_nameType ()
  {
  }

  display_nameType::
  display_nameType (const display_nameType& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->lang_present_ = x.lang_present_;
    if (this->lang_present_)
      this->lang_ = x.lang_;
  }

  display_nameType& display_nameType::
  operator= (const display_nameType& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->lang_present_ = x.lang_present_;
    if (this->lang_present_)
      this->lang_ = x.lang_;
    return *this;
  }

  // display-name
  //

  display_name::
  display_name ()
  {
  }

  display_name::
  ~display_name ()
  {
  }

  display_name::
  display_name (const display_name& x)
  : ::resource_lists::display_nameType (x)
  {
    XSDE_UNUSED (x);
  }

  display_name& display_name::
  operator= (const display_name& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::resource_lists::display_nameType& > (*this) = x;
    return *this;
  }

  // entryType
  //

  entryType::
  entryType ()
  {
    this->display_name_present_ = false;
  }

  entryType::
  ~entryType ()
  {
  }

  entryType::
  entryType (const entryType& x)
  {
    XSDE_UNUSED (x);
    this->uri_ = x.uri_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
  }

  entryType& entryType::
  operator= (const entryType& x)
  {
    XSDE_UNUSED (x);
    this->uri_ = x.uri_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
    return *this;
  }

  // entry-refType
  //

  entry_refType::
  entry_refType ()
  {
    this->display_name_present_ = false;
  }

  entry_refType::
  ~entry_refType ()
  {
  }

  entry_refType::
  entry_refType (const entry_refType& x)
  {
    XSDE_UNUSED (x);
    this->ref_ = x.ref_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
  }

  entry_refType& entry_refType::
  operator= (const entry_refType& x)
  {
    XSDE_UNUSED (x);
    this->ref_ = x.ref_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
    return *this;
  }

  // externalType
  //

  externalType::
  externalType ()
  {
    this->anchor_present_ = false;
    this->display_name_present_ = false;
  }

  externalType::
  ~externalType ()
  {
  }

  externalType::
  externalType (const externalType& x)
  {
    XSDE_UNUSED (x);
    this->anchor_present_ = x.anchor_present_;
    if (this->anchor_present_)
      this->anchor_ = x.anchor_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
  }

  externalType& externalType::
  operator= (const externalType& x)
  {
    XSDE_UNUSED (x);
    this->anchor_present_ = x.anchor_present_;
    if (this->anchor_present_)
      this->anchor_ = x.anchor_;
    this->display_name_present_ = x.display_name_present_;
    if (this->display_name_present_)
      this->display_name_ = x.display_name_;
    return *this;
  }

  // listType
  //

  listType::
  listType ()
  {
    this->name_present_ = false;
    this->display_name_present_ = false;
  }

  listType::
  ~listType ()
  {
  }

  listType::sequence_type::
  sequence_type ()
  {
    this->choice_arm_ = choice_arm_tag (4);
  }

  listType::sequence_type::
  ~sequence_type ()
  {
    this->choice_arm (choice_arm_tag (4));
  }

  void listType::sequence_type::
  choice_arm (choice_arm_tag x)
  {
    if (this->choice_arm_ == x)
      return;

    switch (this->choice_arm_)
    {
      case list_tag:
      {
        delete this->choice_.list_;
        break;
      }
      case external_tag:
      {
        typedef ::resource_lists::externalType _dtor;
        reinterpret_cast< ::resource_lists::externalType& > (this->choice_.external_).~_dtor ();
        break;
      }
      case entry_tag:
      {
        typedef ::resource_lists::entryType _dtor;
        reinterpret_cast< ::resource_lists::entryType& > (this->choice_.entry_).~_dtor ();
        break;
      }
      case entry_ref_tag:
      {
        typedef ::resource_lists::entry_refType _dtor;
        reinterpret_cast< ::resource_lists::entry_refType& > (this->choice_.entry_ref_).~_dtor ();
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = choice_arm_tag (4);

    switch (x)
    {
      case list_tag:
      {
        this->choice_.list_ = 0;
        break;
      }
      case external_tag:
      {
        new (&this->choice_.external_) ::resource_lists::externalType;
        break;
      }
      case entry_tag:
      {
        new (&this->choice_.entry_) ::resource_lists::entryType;
        break;
      }
      case entry_ref_tag:
      {
        new (&this->choice_.entry_ref_) ::resource_lists::entry_refType;
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = x;
  }

  // list
  //

  list::
  list ()
  {
  }

  list::
  ~list ()
  {
  }

  // resource-lists
  //

  resource_lists::
  resource_lists ()
  {
  }

  resource_lists::
  ~resource_lists ()
  {
  }

  resource_lists::sequence_type::
  sequence_type ()
  {
    this->list_ = 0;
  }

  resource_lists::sequence_type::
  ~sequence_type ()
  {
    delete this->list_;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

