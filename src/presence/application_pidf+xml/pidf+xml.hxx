// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef PIDF_XML_HXX
#define PIDF_XML_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

namespace pidf
{
  class note;
  class presence;
  class basic;
  class status;
  class qvalue;
  class contact;
  class tuple;
}


#include "../xml/xml.hxx"

namespace pidf
{
  // note (fixed-length)
  //
  class note: public ::std::string
  {
    public:
    note ();

    note (const note&);
    note& operator= (const note&);

    ~note ();

    // lang
    //
    bool
    lang_present () const;

    void
    lang_present (bool);

    const ::namespace_::lang&
    lang () const;

    ::namespace_::lang&
    lang ();

    void
    lang (const ::namespace_::lang&);

    private:
    ::namespace_::lang lang_;
    unsigned char lang_present_;
  };

  // presence (variable-length)
  //
  class presence
  {
    private:
    presence (const presence&);
    presence& operator= (const presence&);

    public:
    presence ();

    presence*
    _clone () const;

    ~presence ();

    // entity
    //
    const ::std::string&
    entity () const;

    ::std::string&
    entity ();

    void
    entity (const ::std::string&);

    // tuple
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::pidf::tuple > tuple_sequence;
    typedef tuple_sequence::iterator tuple_iterator;
    typedef tuple_sequence::const_iterator tuple_const_iterator;

    const tuple_sequence&
    tuple () const;

    tuple_sequence&
    tuple ();

    // note
    //
    typedef ::xsde::cxx::hybrid::fix_sequence< ::pidf::note > note_sequence;
    typedef note_sequence::iterator note_iterator;
    typedef note_sequence::const_iterator note_const_iterator;

    const note_sequence&
    note () const;

    note_sequence&
    note ();

    void
    _copy (presence&) const;

    private:
    ::std::string entity_;
    tuple_sequence tuple_;
    note_sequence note_;
  };

  // basic (fixed-length)
  //
  class basic
  {
    public:
    enum value_type
    {
      open,
      closed
    };

    basic ();
    basic (value_type);

    void
    value (value_type);

    operator value_type () const
    {
      return value_;
    }

    const char*
    string () const;

    private:
    value_type value_;
  };

  // status (fixed-length)
  //
  class status
  {
    public:
    status ();

    status (const status&);
    status& operator= (const status&);

    ~status ();

    // basic
    //
    bool
    basic_present () const;

    void
    basic_present (bool);

    const ::pidf::basic&
    basic () const;

    ::pidf::basic&
    basic ();

    void
    basic (const ::pidf::basic&);

    private:
    ::pidf::basic basic_;
    unsigned char basic_present_;
  };

  // qvalue (fixed-length)
  //
  class qvalue: public ::xml_schema::decimal_base
  {
    public:
    qvalue ();
  };

  // contact (fixed-length)
  //
  class contact: public ::std::string
  {
    public:
    contact ();

    contact (const contact&);
    contact& operator= (const contact&);

    ~contact ();

    // priority
    //
    bool
    priority_present () const;

    void
    priority_present (bool);

    const ::pidf::qvalue&
    priority () const;

    ::pidf::qvalue&
    priority ();

    void
    priority (const ::pidf::qvalue&);

    private:
    ::pidf::qvalue priority_;
    unsigned char priority_present_;
  };

  // tuple (variable-length)
  //
  class tuple
  {
    private:
    tuple (const tuple&);
    tuple& operator= (const tuple&);

    public:
    tuple ();

    tuple*
    _clone () const;

    ~tuple ();

    // id
    //
    const ::std::string&
    id () const;

    ::std::string&
    id ();

    void
    id (const ::std::string&);

    // status
    //
    const ::pidf::status&
    status () const;

    ::pidf::status&
    status ();

    void
    status (const ::pidf::status&);

    // contact
    //
    bool
    contact_present () const;

    void
    contact_present (bool);

    const ::pidf::contact&
    contact () const;

    ::pidf::contact&
    contact ();

    void
    contact (const ::pidf::contact&);

    // note
    //
    typedef ::xsde::cxx::hybrid::fix_sequence< ::pidf::note > note_sequence;
    typedef note_sequence::iterator note_iterator;
    typedef note_sequence::const_iterator note_const_iterator;

    const note_sequence&
    note () const;

    note_sequence&
    note ();

    // timestamp
    //
    bool
    timestamp_present () const;

    void
    timestamp_present (bool);

    const ::xml_schema::date_time&
    timestamp () const;

    ::xml_schema::date_time&
    timestamp ();

    void
    timestamp (const ::xml_schema::date_time&);

    void
    _copy (tuple&) const;

    private:
    ::std::string id_;
    ::pidf::status status_;
    ::pidf::contact contact_;
    unsigned char contact_present_;
    note_sequence note_;
    ::xml_schema::date_time timestamp_;
    unsigned char timestamp_present_;
  };
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // PIDF_XML_HXX
