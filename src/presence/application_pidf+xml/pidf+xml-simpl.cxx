// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "pidf+xml-simpl.hxx"

#include <xsde/cxx/serializer/validating/string-common.hxx>

namespace pidf
{
  // note_simpl
  //

  note_simpl::
  note_simpl ()
  : note_sskel (&base_impl_)
  {
  }

  void note_simpl::
  pre (const ::pidf::note& x)
  {
    this->base_impl_.pre (x);
    this->note_simpl_state_.note_ = &x;
  }

  bool note_simpl::
  lang_present ()
  {
    return this->note_simpl_state_.note_->lang_present ();
  }

  const ::namespace_::lang& note_simpl::
  lang ()
  {
    return this->note_simpl_state_.note_->lang ();
  }

  // presence_simpl
  //

  void presence_simpl::
  pre (const ::pidf::presence& x)
  {
    this->presence_simpl_state_.presence_ = &x;
    this->presence_simpl_state_.tuple_ = 
    this->presence_simpl_state_.presence_->tuple ().begin ();
    this->presence_simpl_state_.tuple_end_ = 
    this->presence_simpl_state_.presence_->tuple ().end ();
    this->presence_simpl_state_.note_ = 
    this->presence_simpl_state_.presence_->note ().begin ();
    this->presence_simpl_state_.note_end_ = 
    this->presence_simpl_state_.presence_->note ().end ();
  }

  ::std::string presence_simpl::
  entity ()
  {
    return this->presence_simpl_state_.presence_->entity ();
  }

  bool presence_simpl::
  tuple_next ()
  {
    return this->presence_simpl_state_.tuple_ != 
    this->presence_simpl_state_.tuple_end_;
  }

  const ::pidf::tuple& presence_simpl::
  tuple ()
  {
    return *this->presence_simpl_state_.tuple_++;
  }

  bool presence_simpl::
  note_next ()
  {
    return this->presence_simpl_state_.note_ != 
    this->presence_simpl_state_.note_end_;
  }

  const ::pidf::note& presence_simpl::
  note ()
  {
    return *this->presence_simpl_state_.note_++;
  }

  // basic_simpl
  //

  basic_simpl::
  basic_simpl ()
  : basic_sskel (0)
  {
  }

  void basic_simpl::
  pre (const ::pidf::basic& x)
  {
    this->basic_simpl_state_ = &x;
  }

  void basic_simpl::
  _serialize_content ()
  {
    if (::xsde::cxx::serializer::validating::string_common::validate_facets (
          this->basic_simpl_state_->string (),
          this->_facets (),
          this->_context ()))
      this->_characters (this->basic_simpl_state_->string ());
  }

  // status_simpl
  //

  void status_simpl::
  pre (const ::pidf::status& x)
  {
    this->status_simpl_state_.status_ = &x;
  }

  bool status_simpl::
  basic_present ()
  {
    return this->status_simpl_state_.status_->basic_present ();
  }

  const ::pidf::basic& status_simpl::
  basic ()
  {
    return this->status_simpl_state_.status_->basic ();
  }

  // qvalue_simpl
  //

  qvalue_simpl::
  qvalue_simpl ()
  : qvalue_sskel (&base_impl_)
  {
  }

  void qvalue_simpl::
  pre (const ::pidf::qvalue& x)
  {
    this->base_impl_.pre (x);
  }

  // contact_simpl
  //

  contact_simpl::
  contact_simpl ()
  : contact_sskel (&base_impl_)
  {
  }

  void contact_simpl::
  pre (const ::pidf::contact& x)
  {
    this->base_impl_.pre (x);
    this->contact_simpl_state_.contact_ = &x;
  }

  bool contact_simpl::
  priority_present ()
  {
    return this->contact_simpl_state_.contact_->priority_present ();
  }

  const ::pidf::qvalue& contact_simpl::
  priority ()
  {
    return this->contact_simpl_state_.contact_->priority ();
  }

  // tuple_simpl
  //

  void tuple_simpl::
  pre (const ::pidf::tuple& x)
  {
    this->tuple_simpl_state_.tuple_ = &x;
    this->tuple_simpl_state_.note_ = 
    this->tuple_simpl_state_.tuple_->note ().begin ();
    this->tuple_simpl_state_.note_end_ = 
    this->tuple_simpl_state_.tuple_->note ().end ();
  }

  ::std::string tuple_simpl::
  id ()
  {
    return this->tuple_simpl_state_.tuple_->id ();
  }

  const ::pidf::status& tuple_simpl::
  status ()
  {
    return this->tuple_simpl_state_.tuple_->status ();
  }

  bool tuple_simpl::
  contact_present ()
  {
    return this->tuple_simpl_state_.tuple_->contact_present ();
  }

  const ::pidf::contact& tuple_simpl::
  contact ()
  {
    return this->tuple_simpl_state_.tuple_->contact ();
  }

  bool tuple_simpl::
  note_next ()
  {
    return this->tuple_simpl_state_.note_ != 
    this->tuple_simpl_state_.note_end_;
  }

  const ::pidf::note& tuple_simpl::
  note ()
  {
    return *this->tuple_simpl_state_.note_++;
  }

  bool tuple_simpl::
  timestamp_present ()
  {
    return this->tuple_simpl_state_.tuple_->timestamp_present ();
  }

  ::xml_schema::date_time tuple_simpl::
  timestamp ()
  {
    return this->tuple_simpl_state_.tuple_->timestamp ();
  }
}

namespace pidf
{
  // presence_saggr
  //

  presence_saggr::
  presence_saggr ()
  {
    this->status_s_.serializers (this->basic_s_);

    this->contact_s_.serializers (this->qvalue_s_);

    this->note_s_.serializers (this->lang_s_);

    this->presence_s_.serializers (this->uri_s_,
                                   this->tuple_s_,
                                   this->note_s_);

    this->tuple_s_.serializers (this->id_s_,
                                this->status_s_,
                                this->contact_s_,
                                this->note_s_,
                                this->date_time_s_);
  }

  const char* presence_saggr::
  root_name ()
  {
    return "presence";
  }

  const char* presence_saggr::
  root_namespace ()
  {
    return "urn:ietf:params:xml:ns:pidf";
  }
}

// Begin epilogue.
//
//
// End epilogue.

