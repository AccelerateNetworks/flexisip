// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "pidf+xml.hxx"

namespace pidf
{
  // note
  //

  bool note::
  lang_present () const
  {
    return this->lang_present_;
  }

  void note::
  lang_present (bool x)
  {
    this->lang_present_ = x;
  }

  const ::namespace_::lang& note::
  lang () const
  {
    return this->lang_;
  }

  ::namespace_::lang& note::
  lang ()
  {
    return this->lang_;
  }

  void note::
  lang (const ::namespace_::lang& x)
  {
    this->lang_ = x;
    this->lang_present_ = true;
  }

  // presence
  //

  const ::std::string& presence::
  entity () const
  {
    return this->entity_;
  }

  ::std::string& presence::
  entity ()
  {
    return this->entity_;
  }

  void presence::
  entity (const ::std::string& x)
  {
    this->entity_ = x;
  }

  const presence::tuple_sequence& presence::
  tuple () const
  {
    return this->tuple_;
  }

  presence::tuple_sequence& presence::
  tuple ()
  {
    return this->tuple_;
  }

  const presence::note_sequence& presence::
  note () const
  {
    return this->note_;
  }

  presence::note_sequence& presence::
  note ()
  {
    return this->note_;
  }

  // basic
  //

  basic::
  basic ()
  {
  }

  basic::
  basic (value_type v)
  {
    value_ = v;
  }

  void basic::
  value (value_type v)
  {
    value_ = v;
  }

  // status
  //

  bool status::
  basic_present () const
  {
    return this->basic_present_;
  }

  void status::
  basic_present (bool x)
  {
    this->basic_present_ = x;
  }

  const ::pidf::basic& status::
  basic () const
  {
    return this->basic_;
  }

  ::pidf::basic& status::
  basic ()
  {
    return this->basic_;
  }

  void status::
  basic (const ::pidf::basic& x)
  {
    this->basic_ = x;
    this->basic_present_ = true;
  }

  // qvalue
  //

  // contact
  //

  bool contact::
  priority_present () const
  {
    return this->priority_present_;
  }

  void contact::
  priority_present (bool x)
  {
    this->priority_present_ = x;
  }

  const ::pidf::qvalue& contact::
  priority () const
  {
    return this->priority_;
  }

  ::pidf::qvalue& contact::
  priority ()
  {
    return this->priority_;
  }

  void contact::
  priority (const ::pidf::qvalue& x)
  {
    this->priority_ = x;
    this->priority_present_ = true;
  }

  // tuple
  //

  const ::std::string& tuple::
  id () const
  {
    return this->id_;
  }

  ::std::string& tuple::
  id ()
  {
    return this->id_;
  }

  void tuple::
  id (const ::std::string& x)
  {
    this->id_ = x;
  }

  const ::pidf::status& tuple::
  status () const
  {
    return this->status_;
  }

  ::pidf::status& tuple::
  status ()
  {
    return this->status_;
  }

  void tuple::
  status (const ::pidf::status& x)
  {
    this->status_ = x;
  }

  bool tuple::
  contact_present () const
  {
    return this->contact_present_;
  }

  void tuple::
  contact_present (bool x)
  {
    this->contact_present_ = x;
  }

  const ::pidf::contact& tuple::
  contact () const
  {
    return this->contact_;
  }

  ::pidf::contact& tuple::
  contact ()
  {
    return this->contact_;
  }

  void tuple::
  contact (const ::pidf::contact& x)
  {
    this->contact_ = x;
    this->contact_present_ = true;
  }

  const tuple::note_sequence& tuple::
  note () const
  {
    return this->note_;
  }

  tuple::note_sequence& tuple::
  note ()
  {
    return this->note_;
  }

  bool tuple::
  timestamp_present () const
  {
    return this->timestamp_present_;
  }

  void tuple::
  timestamp_present (bool x)
  {
    this->timestamp_present_ = x;
  }

  const ::xml_schema::date_time& tuple::
  timestamp () const
  {
    return this->timestamp_;
  }

  ::xml_schema::date_time& tuple::
  timestamp ()
  {
    return this->timestamp_;
  }

  void tuple::
  timestamp (const ::xml_schema::date_time& x)
  {
    this->timestamp_ = x;
    this->timestamp_present_ = true;
  }
}

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace pidf
{
  // note
  //

  note::
  note ()
  {
    this->lang_present_ = false;
  }

  note::
  ~note ()
  {
  }

  note::
  note (const note& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->lang_present_ = x.lang_present_;
    if (this->lang_present_)
      this->lang_ = x.lang_;
  }

  note& note::
  operator= (const note& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->lang_present_ = x.lang_present_;
    if (this->lang_present_)
      this->lang_ = x.lang_;
    return *this;
  }

  // presence
  //

  presence::
  presence ()
  {
  }

  presence::
  ~presence ()
  {
  }

  void presence::
  _copy (presence& c) const
  {
    XSDE_UNUSED (c);

    c.entity (this->entity ());

    this->tuple ().copy (c.tuple ());

    this->note ().copy (c.note ());
  }

  presence* presence::
  _clone () const
  {
    presence* c = new presence;
    ::xsde::cxx::guard< presence > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // basic
  //

  static const char* _xsde_basic_enumerators_[] = 
  {
    "open",
    "closed"
  };

  const char* basic::
  string () const
  {
    return _xsde_basic_enumerators_[value_];
  }

  // status
  //

  status::
  status ()
  {
    this->basic_present_ = false;
  }

  status::
  ~status ()
  {
  }

  status::
  status (const status& x)
  {
    XSDE_UNUSED (x);
    this->basic_present_ = x.basic_present_;
    if (this->basic_present_)
      this->basic_ = x.basic_;
  }

  status& status::
  operator= (const status& x)
  {
    XSDE_UNUSED (x);
    this->basic_present_ = x.basic_present_;
    if (this->basic_present_)
      this->basic_ = x.basic_;
    return *this;
  }

  // qvalue
  //

  qvalue::
  qvalue ()
  {
  }

  // contact
  //

  contact::
  contact ()
  {
    this->priority_present_ = false;
  }

  contact::
  ~contact ()
  {
  }

  contact::
  contact (const contact& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->priority_present_ = x.priority_present_;
    if (this->priority_present_)
      this->priority_ = x.priority_;
  }

  contact& contact::
  operator= (const contact& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->priority_present_ = x.priority_present_;
    if (this->priority_present_)
      this->priority_ = x.priority_;
    return *this;
  }

  // tuple
  //

  tuple::
  tuple ()
  {
    this->contact_present_ = false;
    this->timestamp_present_ = false;
  }

  tuple::
  ~tuple ()
  {
  }

  void tuple::
  _copy (tuple& c) const
  {
    XSDE_UNUSED (c);

    c.id (this->id ());

    c.status (this->status ());

    if (this->contact_present ())
      c.contact (this->contact ());

    this->note ().copy (c.note ());

    if (this->timestamp_present ())
      c.timestamp (this->timestamp ());
  }

  tuple* tuple::
  _clone () const
  {
    tuple* c = new tuple;
    ::xsde::cxx::guard< tuple > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

